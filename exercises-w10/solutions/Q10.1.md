# Q10.1 Theory Questions Solutions

## 1. C++ Basics and STL

**Compare and contrast `std::vector`, `std::list`, and `std::deque`. When would you use each?**
- `std::vector`: Dynamic array, fast random access, efficient push_back, slow insert/erase except at end. Use when you need fast access and mostly append operations.
- `std::list`: Doubly-linked list, fast insert/erase anywhere, slow random access, more memory overhead. Use when you need frequent insertions/removals in the middle.
- `std::deque`: Double-ended queue, fast insert/erase at both ends, random access, but more complex internals. Use when you need to add/remove from both ends efficiently.

**Explain the difference between `push_back()` and `emplace_back()` in STL containers.**
- `push_back()`: Copies or moves an existing object into the container.
- `emplace_back()`: Constructs the object in-place using provided arguments, avoiding unnecessary copies/moves.

**What are the advantages and disadvantages of using range-based for loops?**
- Advantages: Concise, less error-prone, works with any iterable, improves readability.
- Disadvantages: Cannot access the index directly, cannot modify the container structure during iteration.

## 2. Class Types

**Explain the difference between composition and inheritance. When would you use each?**
- Composition: A class contains objects of other classes. Use for "has-a" relationships and better encapsulation.
- Inheritance: A class derives from another class. Use for "is-a" relationships and polymorphism.

**What is the purpose of virtual destructors? When are they necessary?**
- Ensures the correct destructor is called for derived objects when deleting via a base pointer. Necessary when using polymorphism.

## 3. Operator Overloading

**What are the key principles and best practices for operator overloading in C++?**
- Maintain intuitive semantics (e.g., `+` should be commutative)
- Follow the principle of least surprise
- Consider whether to implement as member or non-member functions
- Ensure exception safety
- Return appropriate types (references for compound assignment, new objects for arithmetic)

**Explain the difference between member and non-member operator overloads.**
- Member operators: Have access to private members, left operand must be class type
- Non-member operators: Can be friends or free functions, more flexible for symmetric operations (e.g., `int + MyClass`)

## 4. Custom Iterators

**How do you implement custom iterators in C++? What are the essential iterator concepts?**
- Implement required typedefs (`value_type`, `reference`, `pointer`, `difference_type`, `iterator_category`)
- Provide required operations (`operator++`, `operator--`, `operator*`, `operator->`, `operator==`, `operator!=`)
- Follow iterator category requirements (input, output, forward, bidirectional, random access)

**Explain the iterator categories and their requirements.**
- Input: Single-pass, read-only (`operator++`, `operator*`, `operator==`)
- Output: Single-pass, write-only (`operator++`, `operator*`)
- Forward: Multi-pass, read/write (`operator++`, `operator*`, `operator==`)
- Bidirectional: Forward + `operator--`
- Random Access: Bidirectional + arithmetic operations (`operator+`, `operator-`, `operator[]`)

## 5. Exception Handling

**What is exception handling, why do we need it? and give an usage example.**
- Exception handling is a mechanism to handle runtime errors and exceptional conditions in a controlled manner.
- We need it to prevent program crashes, provide graceful error recovery, and maintain program stability.
- Example:
  ```cpp
  try {
      std::vector<int> vec;
      int value = vec.at(10);  // This will throw std::out_of_range
  } catch (const std::out_of_range& e) {
      std::cerr << "Index out of bounds: " << e.what() << std::endl;
  } catch (const std::exception& e) {
      std::cerr << "General error: " << e.what() << std::endl;
  }
  ```

**When should you use exceptions versus error codes?**
- Use exceptions for unrecoverable errors or when error handling would clutter code. Use error codes for expected, recoverable errors.

**What is the purpose of the `noexcept` specifier?**
- Indicates a function does not throw exceptions. Enables optimizations and clearer intent.

## 6. Resource Management and Smart Pointers

**Explain RAII and its importance in C++.**
- RAII (Resource Acquisition Is Initialization): Resources are acquired and released by objects' constructors/destructors. Ensures exception safety and prevents leaks.

**Compare `std::unique_ptr`, `std::shared_ptr`, and `std::weak_ptr`.**
- `std::unique_ptr`: Sole ownership, non-copyable, lightweight.
- `std::shared_ptr`: Shared ownership, reference counting, heavier.
- `std::weak_ptr`: Non-owning reference to a `shared_ptr`, prevents cycles.

**What are the benefits of using smart pointers over raw pointers?**
- Automatic memory management, exception safety, prevents leaks and dangling pointers.

**Explain the RAII (Resource Acquisition Is Initialization) pattern in detail. How does it relate to object lifetime management?**
- RAII ties resource lifetime to object lifetime. When an object is created, it acquires resources; when destroyed, it releases them. This ensures resources are properly managed even in the presence of exceptions.

**What are the main advantages of using smart pointers over raw pointers? Explain how they prevent memory leaks.**
- Smart pointers automatically delete the pointed-to object when the pointer goes out of scope, preventing memory leaks. They also provide exception safety and make ownership semantics explicit.

## 7. Polymorphism

**Compare and contrast static and dynamic polymorphism.**
- Static: Resolved at compile time (e.g., templates, function overloading). Faster, but less flexible.
- Dynamic: Resolved at runtime (e.g., virtual functions). More flexible, but incurs runtime overhead.

**What is the difference between static and dynamic polymorphism? Explain when each is resolved and provide examples.**
- Static polymorphism is resolved at compile-time through templates or function overloading. Examples: `std::vector<int>` vs `std::vector<double>`, function overloading.
- Dynamic polymorphism is resolved at runtime through virtual functions. Examples: calling virtual functions through base class pointers.

## 8. Metaprogramming

**What is metaprogramming and what are the benefit of using it in C++? (Give at least three benefits)**
- Metaprogramming is writing code that generates or manipulates code at compile time.
- Benefits:
  - Compile-time computation and optimization
  - Type safety and compile-time error detection
  - Code generation and reduction of boilerplate
  - Performance improvements through compile-time decisions
  - Generic programming and code reuse
  - Zero-cost abstractions with no runtime overhead

**What are type traits in C++? Give an example of how they are used to write generic code.**
- Type traits are compile-time templates that provide information about types (e.g., `std::is_integral<T>`). Example:
  ```cpp
  template<typename T>
  void foo(T x) {
      if constexpr (std::is_integral_v<T>) {
          // Handle integral types
      } else {
          // Handle other types
      }
  }
  ```


**How do type traits work in C++? Explain their role in compile-time type checking and provide examples.**
- Type traits use template specialization to provide compile-time information about types. They enable conditional compilation and generic programming. Example: `std::is_pointer<T>` to check if a type is a pointer. 